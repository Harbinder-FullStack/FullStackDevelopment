<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multi-Stage Docker Image Creation</title>
  <style>
    body { font-family: 'Segoe UI', sans-serif; line-height: 1.6; margin: 2rem; }
    h1, h2 { color: #007acc; }
    img { max-width: 100%; border-radius: 8px; box-shadow: 0 0 6px #ddd; }
    ol { margin-left: 1.5rem; }
  </style>
</head>
<body>
  <h1>Multi-Stage Docker Image Creation</h1>
  <p>This section covers building optimized Docker images for a full-stack app using React, Node/Express, and MongoDB.</p>

  <h2>ğŸ’¡ Why Itâ€™s Needed</h2>
  <p>Multi-stage builds reduce image size, improve build time, and separate build dependencies from production code. 
  Theyâ€™re ideal for full-stack apps where frontend and backend each have their own dependencies.</p>

  <h2>ğŸ§© Steps to Create</h2>
  <ol>
    <li><b>Setup project structure:</b> Have <code>client/</code> (React), <code>server/</code> (Node/Express), and database service ready.</li>
    <li><b>Create Dockerfile for React app:</b> Use Node for build stage, Nginx for serve stage.</li>
    <li><b>Create Dockerfile for Node API:</b> Use multi-stage build to install and copy only production files.</li>
    <li><b>Use official Mongo image:</b> Add volume for persistence and network link with backend.</li>
    <li><b>Combine using docker-compose.yml:</b> Define services for frontend, backend, and Mongo.</li>
    <li><b>Build and run:</b>  
      <pre><code>docker-compose build
docker-compose up</code></pre>
    </li>
  </ol>

  <h2>ğŸ–¼ï¸ Architecture Diagram</h2>
  <img src="images/docker-architecture-1.webp" alt="Multi-stage Docker Image Creation Diagram" />

  <h2>ğŸ”— Next Step</h2>
  <p>After creating Docker images, the next stage is automating the build and deployment process using GitHub Actions.</p>

  <a href="github-actions.html">Go to â†’ GitHub Actions Setup</a>
</body>
</html>
